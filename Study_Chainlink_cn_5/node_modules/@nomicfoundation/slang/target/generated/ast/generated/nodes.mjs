// This file is generated automatically by infrastructure scripts. Please don't edit by hand.
import * as generated from "../../../../wasm/index.mjs";
import { NonterminalKind } from "../../cst/index.mjs";
/*
 * Sequences:
 */
export class SourceUnit {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$members] = generated.ast.Selectors.sequence(this.cst);
            return {
                members: new SourceUnitMembers($members),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.SourceUnit);
    }
    get members() {
        return this.fetch().members;
    }
}
export class PragmaDirective {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$pragmaKeyword, $pragma, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                pragmaKeyword: $pragmaKeyword,
                pragma: new Pragma($pragma),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.PragmaDirective);
    }
    get pragmaKeyword() {
        return this.fetch().pragmaKeyword;
    }
    get pragma() {
        return this.fetch().pragma;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class AbicoderPragma {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$abicoderKeyword, $version] = generated.ast.Selectors.sequence(this.cst);
            return {
                abicoderKeyword: $abicoderKeyword,
                version: $version,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.AbicoderPragma);
    }
    get abicoderKeyword() {
        return this.fetch().abicoderKeyword;
    }
    get version() {
        return this.fetch().version;
    }
}
export class ExperimentalPragma {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$experimentalKeyword, $feature] = generated.ast.Selectors.sequence(this.cst);
            return {
                experimentalKeyword: $experimentalKeyword,
                feature: new ExperimentalFeature($feature),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ExperimentalPragma);
    }
    get experimentalKeyword() {
        return this.fetch().experimentalKeyword;
    }
    get feature() {
        return this.fetch().feature;
    }
}
export class VersionPragma {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$solidityKeyword, $sets] = generated.ast.Selectors.sequence(this.cst);
            return {
                solidityKeyword: $solidityKeyword,
                sets: new VersionExpressionSets($sets),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.VersionPragma);
    }
    get solidityKeyword() {
        return this.fetch().solidityKeyword;
    }
    get sets() {
        return this.fetch().sets;
    }
}
export class VersionRange {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$start, $minus, $end] = generated.ast.Selectors.sequence(this.cst);
            return {
                start: new VersionLiteral($start),
                minus: $minus,
                end: new VersionLiteral($end),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.VersionRange);
    }
    get start() {
        return this.fetch().start;
    }
    get minus() {
        return this.fetch().minus;
    }
    get end() {
        return this.fetch().end;
    }
}
export class VersionTerm {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operator, $literal] = generated.ast.Selectors.sequence(this.cst);
            return {
                operator: $operator === undefined ? undefined : new VersionOperator($operator),
                literal: new VersionLiteral($literal),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.VersionTerm);
    }
    get operator() {
        return this.fetch().operator;
    }
    get literal() {
        return this.fetch().literal;
    }
}
export class ImportDirective {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$importKeyword, $clause, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                importKeyword: $importKeyword,
                clause: new ImportClause($clause),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ImportDirective);
    }
    get importKeyword() {
        return this.fetch().importKeyword;
    }
    get clause() {
        return this.fetch().clause;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class PathImport {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$path, $alias] = generated.ast.Selectors.sequence(this.cst);
            return {
                path: new StringLiteral($path),
                alias: $alias === undefined ? undefined : new ImportAlias($alias),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.PathImport);
    }
    get path() {
        return this.fetch().path;
    }
    get alias() {
        return this.fetch().alias;
    }
}
export class NamedImport {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$asterisk, $alias, $fromKeyword, $path] = generated.ast.Selectors.sequence(this.cst);
            return {
                asterisk: $asterisk,
                alias: new ImportAlias($alias),
                fromKeyword: $fromKeyword,
                path: new StringLiteral($path),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.NamedImport);
    }
    get asterisk() {
        return this.fetch().asterisk;
    }
    get alias() {
        return this.fetch().alias;
    }
    get fromKeyword() {
        return this.fetch().fromKeyword;
    }
    get path() {
        return this.fetch().path;
    }
}
export class ImportDeconstruction {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBrace, $symbols, $closeBrace, $fromKeyword, $path] = generated.ast.Selectors.sequence(this.cst);
            return {
                openBrace: $openBrace,
                symbols: new ImportDeconstructionSymbols($symbols),
                closeBrace: $closeBrace,
                fromKeyword: $fromKeyword,
                path: new StringLiteral($path),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ImportDeconstruction);
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get symbols() {
        return this.fetch().symbols;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
    get fromKeyword() {
        return this.fetch().fromKeyword;
    }
    get path() {
        return this.fetch().path;
    }
}
export class ImportDeconstructionSymbol {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$name, $alias] = generated.ast.Selectors.sequence(this.cst);
            return {
                name: $name,
                alias: $alias === undefined ? undefined : new ImportAlias($alias),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ImportDeconstructionSymbol);
    }
    get name() {
        return this.fetch().name;
    }
    get alias() {
        return this.fetch().alias;
    }
}
export class ImportAlias {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$asKeyword, $identifier] = generated.ast.Selectors.sequence(this.cst);
            return {
                asKeyword: $asKeyword,
                identifier: $identifier,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ImportAlias);
    }
    get asKeyword() {
        return this.fetch().asKeyword;
    }
    get identifier() {
        return this.fetch().identifier;
    }
}
export class UsingDirective {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$usingKeyword, $clause, $forKeyword, $target, $globalKeyword, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                usingKeyword: $usingKeyword,
                clause: new UsingClause($clause),
                forKeyword: $forKeyword,
                target: new UsingTarget($target),
                globalKeyword: $globalKeyword === undefined ? undefined : $globalKeyword,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.UsingDirective);
    }
    get usingKeyword() {
        return this.fetch().usingKeyword;
    }
    get clause() {
        return this.fetch().clause;
    }
    get forKeyword() {
        return this.fetch().forKeyword;
    }
    get target() {
        return this.fetch().target;
    }
    get globalKeyword() {
        return this.fetch().globalKeyword;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class UsingDeconstruction {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBrace, $symbols, $closeBrace] = generated.ast.Selectors.sequence(this.cst);
            return {
                openBrace: $openBrace,
                symbols: new UsingDeconstructionSymbols($symbols),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.UsingDeconstruction);
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get symbols() {
        return this.fetch().symbols;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
export class UsingDeconstructionSymbol {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$name, $alias] = generated.ast.Selectors.sequence(this.cst);
            return {
                name: new IdentifierPath($name),
                alias: $alias === undefined ? undefined : new UsingAlias($alias),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.UsingDeconstructionSymbol);
    }
    get name() {
        return this.fetch().name;
    }
    get alias() {
        return this.fetch().alias;
    }
}
export class UsingAlias {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$asKeyword, $operator] = generated.ast.Selectors.sequence(this.cst);
            return {
                asKeyword: $asKeyword,
                operator: new UsingOperator($operator),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.UsingAlias);
    }
    get asKeyword() {
        return this.fetch().asKeyword;
    }
    get operator() {
        return this.fetch().operator;
    }
}
export class ContractDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$abstractKeyword, $contractKeyword, $name, $inheritance, $openBrace, $members, $closeBrace] = generated.ast.Selectors.sequence(this.cst);
            return {
                abstractKeyword: $abstractKeyword === undefined ? undefined : $abstractKeyword,
                contractKeyword: $contractKeyword,
                name: $name,
                inheritance: $inheritance === undefined ? undefined : new InheritanceSpecifier($inheritance),
                openBrace: $openBrace,
                members: new ContractMembers($members),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ContractDefinition);
    }
    get abstractKeyword() {
        return this.fetch().abstractKeyword;
    }
    get contractKeyword() {
        return this.fetch().contractKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get inheritance() {
        return this.fetch().inheritance;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get members() {
        return this.fetch().members;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
export class InheritanceSpecifier {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$isKeyword, $types] = generated.ast.Selectors.sequence(this.cst);
            return {
                isKeyword: $isKeyword,
                types: new InheritanceTypes($types),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.InheritanceSpecifier);
    }
    get isKeyword() {
        return this.fetch().isKeyword;
    }
    get types() {
        return this.fetch().types;
    }
}
export class InheritanceType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $arguments] = generated.ast.Selectors.sequence(this.cst);
            return {
                typeName: new IdentifierPath($typeName),
                arguments: $arguments === undefined ? undefined : new ArgumentsDeclaration($arguments),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.InheritanceType);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get arguments() {
        return this.fetch().arguments;
    }
}
export class InterfaceDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$interfaceKeyword, $name, $inheritance, $openBrace, $members, $closeBrace] = generated.ast.Selectors.sequence(this.cst);
            return {
                interfaceKeyword: $interfaceKeyword,
                name: $name,
                inheritance: $inheritance === undefined ? undefined : new InheritanceSpecifier($inheritance),
                openBrace: $openBrace,
                members: new InterfaceMembers($members),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.InterfaceDefinition);
    }
    get interfaceKeyword() {
        return this.fetch().interfaceKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get inheritance() {
        return this.fetch().inheritance;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get members() {
        return this.fetch().members;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
export class LibraryDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$libraryKeyword, $name, $openBrace, $members, $closeBrace] = generated.ast.Selectors.sequence(this.cst);
            return {
                libraryKeyword: $libraryKeyword,
                name: $name,
                openBrace: $openBrace,
                members: new LibraryMembers($members),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.LibraryDefinition);
    }
    get libraryKeyword() {
        return this.fetch().libraryKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get members() {
        return this.fetch().members;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
export class StructDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$structKeyword, $name, $openBrace, $members, $closeBrace] = generated.ast.Selectors.sequence(this.cst);
            return {
                structKeyword: $structKeyword,
                name: $name,
                openBrace: $openBrace,
                members: new StructMembers($members),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.StructDefinition);
    }
    get structKeyword() {
        return this.fetch().structKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get members() {
        return this.fetch().members;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
export class StructMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $name, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                name: $name,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.StructMember);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get name() {
        return this.fetch().name;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class EnumDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$enumKeyword, $name, $openBrace, $members, $closeBrace] = generated.ast.Selectors.sequence(this.cst);
            return {
                enumKeyword: $enumKeyword,
                name: $name,
                openBrace: $openBrace,
                members: new EnumMembers($members),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.EnumDefinition);
    }
    get enumKeyword() {
        return this.fetch().enumKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get members() {
        return this.fetch().members;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
export class ConstantDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $constantKeyword, $name, $equal, $value, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                constantKeyword: $constantKeyword,
                name: $name,
                equal: $equal,
                value: new Expression($value),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ConstantDefinition);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get constantKeyword() {
        return this.fetch().constantKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get equal() {
        return this.fetch().equal;
    }
    get value() {
        return this.fetch().value;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class StateVariableDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $attributes, $name, $value, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                attributes: new StateVariableAttributes($attributes),
                name: $name,
                value: $value === undefined ? undefined : new StateVariableDefinitionValue($value),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.StateVariableDefinition);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get name() {
        return this.fetch().name;
    }
    get value() {
        return this.fetch().value;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class StateVariableDefinitionValue {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$equal, $value] = generated.ast.Selectors.sequence(this.cst);
            return {
                equal: $equal,
                value: new Expression($value),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.StateVariableDefinitionValue);
    }
    get equal() {
        return this.fetch().equal;
    }
    get value() {
        return this.fetch().value;
    }
}
export class FunctionDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$functionKeyword, $name, $parameters, $attributes, $returns, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                functionKeyword: $functionKeyword,
                name: new FunctionName($name),
                parameters: new ParametersDeclaration($parameters),
                attributes: new FunctionAttributes($attributes),
                returns: $returns === undefined ? undefined : new ReturnsDeclaration($returns),
                body: new FunctionBody($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.FunctionDefinition);
    }
    get functionKeyword() {
        return this.fetch().functionKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get returns() {
        return this.fetch().returns;
    }
    get body() {
        return this.fetch().body;
    }
}
export class ParametersDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $parameters, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                openParen: $openParen,
                parameters: new Parameters($parameters),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ParametersDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
export class Parameter {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $storageLocation, $name] = generated.ast.Selectors.sequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                storageLocation: $storageLocation === undefined ? undefined : new StorageLocation($storageLocation),
                name: $name === undefined ? undefined : $name,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.Parameter);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get storageLocation() {
        return this.fetch().storageLocation;
    }
    get name() {
        return this.fetch().name;
    }
}
export class OverrideSpecifier {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$overrideKeyword, $overridden] = generated.ast.Selectors.sequence(this.cst);
            return {
                overrideKeyword: $overrideKeyword,
                overridden: $overridden === undefined ? undefined : new OverridePathsDeclaration($overridden),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.OverrideSpecifier);
    }
    get overrideKeyword() {
        return this.fetch().overrideKeyword;
    }
    get overridden() {
        return this.fetch().overridden;
    }
}
export class OverridePathsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $paths, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                openParen: $openParen,
                paths: new OverridePaths($paths),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.OverridePathsDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get paths() {
        return this.fetch().paths;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
export class ReturnsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$returnsKeyword, $variables] = generated.ast.Selectors.sequence(this.cst);
            return {
                returnsKeyword: $returnsKeyword,
                variables: new ParametersDeclaration($variables),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ReturnsDeclaration);
    }
    get returnsKeyword() {
        return this.fetch().returnsKeyword;
    }
    get variables() {
        return this.fetch().variables;
    }
}
export class ConstructorDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$constructorKeyword, $parameters, $attributes, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                constructorKeyword: $constructorKeyword,
                parameters: new ParametersDeclaration($parameters),
                attributes: new ConstructorAttributes($attributes),
                body: new Block($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ConstructorDefinition);
    }
    get constructorKeyword() {
        return this.fetch().constructorKeyword;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get body() {
        return this.fetch().body;
    }
}
export class UnnamedFunctionDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$functionKeyword, $parameters, $attributes, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                functionKeyword: $functionKeyword,
                parameters: new ParametersDeclaration($parameters),
                attributes: new UnnamedFunctionAttributes($attributes),
                body: new FunctionBody($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.UnnamedFunctionDefinition);
    }
    get functionKeyword() {
        return this.fetch().functionKeyword;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get body() {
        return this.fetch().body;
    }
}
export class FallbackFunctionDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$fallbackKeyword, $parameters, $attributes, $returns, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                fallbackKeyword: $fallbackKeyword,
                parameters: new ParametersDeclaration($parameters),
                attributes: new FallbackFunctionAttributes($attributes),
                returns: $returns === undefined ? undefined : new ReturnsDeclaration($returns),
                body: new FunctionBody($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.FallbackFunctionDefinition);
    }
    get fallbackKeyword() {
        return this.fetch().fallbackKeyword;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get returns() {
        return this.fetch().returns;
    }
    get body() {
        return this.fetch().body;
    }
}
export class ReceiveFunctionDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$receiveKeyword, $parameters, $attributes, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                receiveKeyword: $receiveKeyword,
                parameters: new ParametersDeclaration($parameters),
                attributes: new ReceiveFunctionAttributes($attributes),
                body: new FunctionBody($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ReceiveFunctionDefinition);
    }
    get receiveKeyword() {
        return this.fetch().receiveKeyword;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get body() {
        return this.fetch().body;
    }
}
export class ModifierDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$modifierKeyword, $name, $parameters, $attributes, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                modifierKeyword: $modifierKeyword,
                name: $name,
                parameters: $parameters === undefined ? undefined : new ParametersDeclaration($parameters),
                attributes: new ModifierAttributes($attributes),
                body: new FunctionBody($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ModifierDefinition);
    }
    get modifierKeyword() {
        return this.fetch().modifierKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get body() {
        return this.fetch().body;
    }
}
export class ModifierInvocation {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$name, $arguments] = generated.ast.Selectors.sequence(this.cst);
            return {
                name: new IdentifierPath($name),
                arguments: $arguments === undefined ? undefined : new ArgumentsDeclaration($arguments),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ModifierInvocation);
    }
    get name() {
        return this.fetch().name;
    }
    get arguments() {
        return this.fetch().arguments;
    }
}
export class EventDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$eventKeyword, $name, $parameters, $anonymousKeyword, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                eventKeyword: $eventKeyword,
                name: $name,
                parameters: new EventParametersDeclaration($parameters),
                anonymousKeyword: $anonymousKeyword === undefined ? undefined : $anonymousKeyword,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.EventDefinition);
    }
    get eventKeyword() {
        return this.fetch().eventKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get anonymousKeyword() {
        return this.fetch().anonymousKeyword;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class EventParametersDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $parameters, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                openParen: $openParen,
                parameters: new EventParameters($parameters),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.EventParametersDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
export class EventParameter {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $indexedKeyword, $name] = generated.ast.Selectors.sequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                indexedKeyword: $indexedKeyword === undefined ? undefined : $indexedKeyword,
                name: $name === undefined ? undefined : $name,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.EventParameter);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get indexedKeyword() {
        return this.fetch().indexedKeyword;
    }
    get name() {
        return this.fetch().name;
    }
}
export class UserDefinedValueTypeDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeKeyword, $name, $isKeyword, $valueType, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                typeKeyword: $typeKeyword,
                name: $name,
                isKeyword: $isKeyword,
                valueType: new ElementaryType($valueType),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.UserDefinedValueTypeDefinition);
    }
    get typeKeyword() {
        return this.fetch().typeKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get isKeyword() {
        return this.fetch().isKeyword;
    }
    get valueType() {
        return this.fetch().valueType;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class ErrorDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$errorKeyword, $name, $members, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                errorKeyword: $errorKeyword,
                name: $name,
                members: new ErrorParametersDeclaration($members),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ErrorDefinition);
    }
    get errorKeyword() {
        return this.fetch().errorKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get members() {
        return this.fetch().members;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class ErrorParametersDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $parameters, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                openParen: $openParen,
                parameters: new ErrorParameters($parameters),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ErrorParametersDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
export class ErrorParameter {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $name] = generated.ast.Selectors.sequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                name: $name === undefined ? undefined : $name,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ErrorParameter);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get name() {
        return this.fetch().name;
    }
}
export class ArrayTypeName {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $openBracket, $index, $closeBracket] = generated.ast.Selectors.sequence(this.cst);
            return {
                operand: new TypeName($operand),
                openBracket: $openBracket,
                index: $index === undefined ? undefined : new Expression($index),
                closeBracket: $closeBracket,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ArrayTypeName);
    }
    get operand() {
        return this.fetch().operand;
    }
    get openBracket() {
        return this.fetch().openBracket;
    }
    get index() {
        return this.fetch().index;
    }
    get closeBracket() {
        return this.fetch().closeBracket;
    }
}
export class FunctionType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$functionKeyword, $parameters, $attributes, $returns] = generated.ast.Selectors.sequence(this.cst);
            return {
                functionKeyword: $functionKeyword,
                parameters: new ParametersDeclaration($parameters),
                attributes: new FunctionTypeAttributes($attributes),
                returns: $returns === undefined ? undefined : new ReturnsDeclaration($returns),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.FunctionType);
    }
    get functionKeyword() {
        return this.fetch().functionKeyword;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get attributes() {
        return this.fetch().attributes;
    }
    get returns() {
        return this.fetch().returns;
    }
}
export class MappingType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$mappingKeyword, $openParen, $keyType, $equalGreaterThan, $valueType, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                mappingKeyword: $mappingKeyword,
                openParen: $openParen,
                keyType: new MappingKey($keyType),
                equalGreaterThan: $equalGreaterThan,
                valueType: new MappingValue($valueType),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.MappingType);
    }
    get mappingKeyword() {
        return this.fetch().mappingKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get keyType() {
        return this.fetch().keyType;
    }
    get equalGreaterThan() {
        return this.fetch().equalGreaterThan;
    }
    get valueType() {
        return this.fetch().valueType;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
export class MappingKey {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$keyType, $name] = generated.ast.Selectors.sequence(this.cst);
            return {
                keyType: new MappingKeyType($keyType),
                name: $name === undefined ? undefined : $name,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.MappingKey);
    }
    get keyType() {
        return this.fetch().keyType;
    }
    get name() {
        return this.fetch().name;
    }
}
export class MappingValue {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $name] = generated.ast.Selectors.sequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                name: $name === undefined ? undefined : $name,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.MappingValue);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get name() {
        return this.fetch().name;
    }
}
export class AddressType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$addressKeyword, $payableKeyword] = generated.ast.Selectors.sequence(this.cst);
            return {
                addressKeyword: $addressKeyword,
                payableKeyword: $payableKeyword === undefined ? undefined : $payableKeyword,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.AddressType);
    }
    get addressKeyword() {
        return this.fetch().addressKeyword;
    }
    get payableKeyword() {
        return this.fetch().payableKeyword;
    }
}
export class Block {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBrace, $statements, $closeBrace] = generated.ast.Selectors.sequence(this.cst);
            return {
                openBrace: $openBrace,
                statements: new Statements($statements),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.Block);
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get statements() {
        return this.fetch().statements;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
export class UncheckedBlock {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$uncheckedKeyword, $block] = generated.ast.Selectors.sequence(this.cst);
            return {
                uncheckedKeyword: $uncheckedKeyword,
                block: new Block($block),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.UncheckedBlock);
    }
    get uncheckedKeyword() {
        return this.fetch().uncheckedKeyword;
    }
    get block() {
        return this.fetch().block;
    }
}
export class ExpressionStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$expression, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                expression: new Expression($expression),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ExpressionStatement);
    }
    get expression() {
        return this.fetch().expression;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class AssemblyStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$assemblyKeyword, $label, $flags, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                assemblyKeyword: $assemblyKeyword,
                label: $label === undefined ? undefined : new StringLiteral($label),
                flags: $flags === undefined ? undefined : new AssemblyFlagsDeclaration($flags),
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.AssemblyStatement);
    }
    get assemblyKeyword() {
        return this.fetch().assemblyKeyword;
    }
    get label() {
        return this.fetch().label;
    }
    get flags() {
        return this.fetch().flags;
    }
    get body() {
        return this.fetch().body;
    }
}
export class AssemblyFlagsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $flags, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                openParen: $openParen,
                flags: new AssemblyFlags($flags),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.AssemblyFlagsDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get flags() {
        return this.fetch().flags;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
export class TupleDeconstructionStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$varKeyword, $openParen, $elements, $closeParen, $equal, $expression, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                varKeyword: $varKeyword === undefined ? undefined : $varKeyword,
                openParen: $openParen,
                elements: new TupleDeconstructionElements($elements),
                closeParen: $closeParen,
                equal: $equal,
                expression: new Expression($expression),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.TupleDeconstructionStatement);
    }
    get varKeyword() {
        return this.fetch().varKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get elements() {
        return this.fetch().elements;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
    get equal() {
        return this.fetch().equal;
    }
    get expression() {
        return this.fetch().expression;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class TupleDeconstructionElement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$member] = generated.ast.Selectors.sequence(this.cst);
            return {
                member: $member === undefined ? undefined : new TupleMember($member),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.TupleDeconstructionElement);
    }
    get member() {
        return this.fetch().member;
    }
}
export class TypedTupleMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeName, $storageLocation, $name] = generated.ast.Selectors.sequence(this.cst);
            return {
                typeName: new TypeName($typeName),
                storageLocation: $storageLocation === undefined ? undefined : new StorageLocation($storageLocation),
                name: $name,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.TypedTupleMember);
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get storageLocation() {
        return this.fetch().storageLocation;
    }
    get name() {
        return this.fetch().name;
    }
}
export class UntypedTupleMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$storageLocation, $name] = generated.ast.Selectors.sequence(this.cst);
            return {
                storageLocation: $storageLocation === undefined ? undefined : new StorageLocation($storageLocation),
                name: $name,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.UntypedTupleMember);
    }
    get storageLocation() {
        return this.fetch().storageLocation;
    }
    get name() {
        return this.fetch().name;
    }
}
export class VariableDeclarationStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$variableType, $storageLocation, $name, $value, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                variableType: new VariableDeclarationType($variableType),
                storageLocation: $storageLocation === undefined ? undefined : new StorageLocation($storageLocation),
                name: $name,
                value: $value === undefined ? undefined : new VariableDeclarationValue($value),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.VariableDeclarationStatement);
    }
    get variableType() {
        return this.fetch().variableType;
    }
    get storageLocation() {
        return this.fetch().storageLocation;
    }
    get name() {
        return this.fetch().name;
    }
    get value() {
        return this.fetch().value;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class VariableDeclarationValue {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$equal, $expression] = generated.ast.Selectors.sequence(this.cst);
            return {
                equal: $equal,
                expression: new Expression($expression),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.VariableDeclarationValue);
    }
    get equal() {
        return this.fetch().equal;
    }
    get expression() {
        return this.fetch().expression;
    }
}
export class IfStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$ifKeyword, $openParen, $condition, $closeParen, $body, $elseBranch] = generated.ast.Selectors.sequence(this.cst);
            return {
                ifKeyword: $ifKeyword,
                openParen: $openParen,
                condition: new Expression($condition),
                closeParen: $closeParen,
                body: new Statement($body),
                elseBranch: $elseBranch === undefined ? undefined : new ElseBranch($elseBranch),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.IfStatement);
    }
    get ifKeyword() {
        return this.fetch().ifKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get condition() {
        return this.fetch().condition;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
    get body() {
        return this.fetch().body;
    }
    get elseBranch() {
        return this.fetch().elseBranch;
    }
}
export class ElseBranch {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$elseKeyword, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                elseKeyword: $elseKeyword,
                body: new Statement($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ElseBranch);
    }
    get elseKeyword() {
        return this.fetch().elseKeyword;
    }
    get body() {
        return this.fetch().body;
    }
}
export class ForStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$forKeyword, $openParen, $initialization, $condition, $iterator, $closeParen, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                forKeyword: $forKeyword,
                openParen: $openParen,
                initialization: new ForStatementInitialization($initialization),
                condition: new ForStatementCondition($condition),
                iterator: $iterator === undefined ? undefined : new Expression($iterator),
                closeParen: $closeParen,
                body: new Statement($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ForStatement);
    }
    get forKeyword() {
        return this.fetch().forKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get initialization() {
        return this.fetch().initialization;
    }
    get condition() {
        return this.fetch().condition;
    }
    get iterator() {
        return this.fetch().iterator;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
    get body() {
        return this.fetch().body;
    }
}
export class WhileStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$whileKeyword, $openParen, $condition, $closeParen, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                whileKeyword: $whileKeyword,
                openParen: $openParen,
                condition: new Expression($condition),
                closeParen: $closeParen,
                body: new Statement($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.WhileStatement);
    }
    get whileKeyword() {
        return this.fetch().whileKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get condition() {
        return this.fetch().condition;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
    get body() {
        return this.fetch().body;
    }
}
export class DoWhileStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$doKeyword, $body, $whileKeyword, $openParen, $condition, $closeParen, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                doKeyword: $doKeyword,
                body: new Statement($body),
                whileKeyword: $whileKeyword,
                openParen: $openParen,
                condition: new Expression($condition),
                closeParen: $closeParen,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.DoWhileStatement);
    }
    get doKeyword() {
        return this.fetch().doKeyword;
    }
    get body() {
        return this.fetch().body;
    }
    get whileKeyword() {
        return this.fetch().whileKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get condition() {
        return this.fetch().condition;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class ContinueStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$continueKeyword, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                continueKeyword: $continueKeyword,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ContinueStatement);
    }
    get continueKeyword() {
        return this.fetch().continueKeyword;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class BreakStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$breakKeyword, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                breakKeyword: $breakKeyword,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.BreakStatement);
    }
    get breakKeyword() {
        return this.fetch().breakKeyword;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class ReturnStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$returnKeyword, $expression, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                returnKeyword: $returnKeyword,
                expression: $expression === undefined ? undefined : new Expression($expression),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ReturnStatement);
    }
    get returnKeyword() {
        return this.fetch().returnKeyword;
    }
    get expression() {
        return this.fetch().expression;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class EmitStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$emitKeyword, $event, $arguments, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                emitKeyword: $emitKeyword,
                event: new IdentifierPath($event),
                arguments: new ArgumentsDeclaration($arguments),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.EmitStatement);
    }
    get emitKeyword() {
        return this.fetch().emitKeyword;
    }
    get event() {
        return this.fetch().event;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class TryStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$tryKeyword, $expression, $returns, $body, $catchClauses] = generated.ast.Selectors.sequence(this.cst);
            return {
                tryKeyword: $tryKeyword,
                expression: new Expression($expression),
                returns: $returns === undefined ? undefined : new ReturnsDeclaration($returns),
                body: new Block($body),
                catchClauses: new CatchClauses($catchClauses),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.TryStatement);
    }
    get tryKeyword() {
        return this.fetch().tryKeyword;
    }
    get expression() {
        return this.fetch().expression;
    }
    get returns() {
        return this.fetch().returns;
    }
    get body() {
        return this.fetch().body;
    }
    get catchClauses() {
        return this.fetch().catchClauses;
    }
}
export class CatchClause {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$catchKeyword, $error, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                catchKeyword: $catchKeyword,
                error: $error === undefined ? undefined : new CatchClauseError($error),
                body: new Block($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.CatchClause);
    }
    get catchKeyword() {
        return this.fetch().catchKeyword;
    }
    get error() {
        return this.fetch().error;
    }
    get body() {
        return this.fetch().body;
    }
}
export class CatchClauseError {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$name, $parameters] = generated.ast.Selectors.sequence(this.cst);
            return {
                name: $name === undefined ? undefined : $name,
                parameters: new ParametersDeclaration($parameters),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.CatchClauseError);
    }
    get name() {
        return this.fetch().name;
    }
    get parameters() {
        return this.fetch().parameters;
    }
}
export class RevertStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$revertKeyword, $error, $arguments, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                revertKeyword: $revertKeyword,
                error: $error === undefined ? undefined : new IdentifierPath($error),
                arguments: new ArgumentsDeclaration($arguments),
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.RevertStatement);
    }
    get revertKeyword() {
        return this.fetch().revertKeyword;
    }
    get error() {
        return this.fetch().error;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class ThrowStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$throwKeyword, $semicolon] = generated.ast.Selectors.sequence(this.cst);
            return {
                throwKeyword: $throwKeyword,
                semicolon: $semicolon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ThrowStatement);
    }
    get throwKeyword() {
        return this.fetch().throwKeyword;
    }
    get semicolon() {
        return this.fetch().semicolon;
    }
}
export class AssignmentExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.AssignmentExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class ConditionalExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $questionMark, $trueExpression, $colon, $falseExpression] = generated.ast.Selectors.sequence(this.cst);
            return {
                operand: new Expression($operand),
                questionMark: $questionMark,
                trueExpression: new Expression($trueExpression),
                colon: $colon,
                falseExpression: new Expression($falseExpression),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ConditionalExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get questionMark() {
        return this.fetch().questionMark;
    }
    get trueExpression() {
        return this.fetch().trueExpression;
    }
    get colon() {
        return this.fetch().colon;
    }
    get falseExpression() {
        return this.fetch().falseExpression;
    }
}
export class OrExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.OrExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class AndExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.AndExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class EqualityExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.EqualityExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class ComparisonExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ComparisonExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class BitwiseOrExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.BitwiseOrExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class BitwiseXorExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.BitwiseXorExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class BitwiseAndExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.BitwiseAndExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class ShiftExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ShiftExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class AdditiveExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.AdditiveExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class MultiplicativeExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.MultiplicativeExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class ExponentiationExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leftOperand, $operator, $rightOperand] = generated.ast.Selectors.sequence(this.cst);
            return {
                leftOperand: new Expression($leftOperand),
                operator: $operator,
                rightOperand: new Expression($rightOperand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ExponentiationExpression);
    }
    get leftOperand() {
        return this.fetch().leftOperand;
    }
    get operator() {
        return this.fetch().operator;
    }
    get rightOperand() {
        return this.fetch().rightOperand;
    }
}
export class PostfixExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $operator] = generated.ast.Selectors.sequence(this.cst);
            return {
                operand: new Expression($operand),
                operator: $operator,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.PostfixExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get operator() {
        return this.fetch().operator;
    }
}
export class PrefixExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operator, $operand] = generated.ast.Selectors.sequence(this.cst);
            return {
                operator: $operator,
                operand: new Expression($operand),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.PrefixExpression);
    }
    get operator() {
        return this.fetch().operator;
    }
    get operand() {
        return this.fetch().operand;
    }
}
export class FunctionCallExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $arguments] = generated.ast.Selectors.sequence(this.cst);
            return {
                operand: new Expression($operand),
                arguments: new ArgumentsDeclaration($arguments),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.FunctionCallExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get arguments() {
        return this.fetch().arguments;
    }
}
export class CallOptionsExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $openBrace, $options, $closeBrace] = generated.ast.Selectors.sequence(this.cst);
            return {
                operand: new Expression($operand),
                openBrace: $openBrace,
                options: new CallOptions($options),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.CallOptionsExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get options() {
        return this.fetch().options;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
export class MemberAccessExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $period, $member] = generated.ast.Selectors.sequence(this.cst);
            return {
                operand: new Expression($operand),
                period: $period,
                member: $member,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.MemberAccessExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get period() {
        return this.fetch().period;
    }
    get member() {
        return this.fetch().member;
    }
}
export class IndexAccessExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $openBracket, $start, $end, $closeBracket] = generated.ast.Selectors.sequence(this.cst);
            return {
                operand: new Expression($operand),
                openBracket: $openBracket,
                start: $start === undefined ? undefined : new Expression($start),
                end: $end === undefined ? undefined : new IndexAccessEnd($end),
                closeBracket: $closeBracket,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.IndexAccessExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get openBracket() {
        return this.fetch().openBracket;
    }
    get start() {
        return this.fetch().start;
    }
    get end() {
        return this.fetch().end;
    }
    get closeBracket() {
        return this.fetch().closeBracket;
    }
}
export class IndexAccessEnd {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$colon, $end] = generated.ast.Selectors.sequence(this.cst);
            return {
                colon: $colon,
                end: $end === undefined ? undefined : new Expression($end),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.IndexAccessEnd);
    }
    get colon() {
        return this.fetch().colon;
    }
    get end() {
        return this.fetch().end;
    }
}
export class PositionalArgumentsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $arguments, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                openParen: $openParen,
                arguments: new PositionalArguments($arguments),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.PositionalArgumentsDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
export class NamedArgumentsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $arguments, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                openParen: $openParen,
                arguments: $arguments === undefined ? undefined : new NamedArgumentGroup($arguments),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.NamedArgumentsDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
export class NamedArgumentGroup {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBrace, $arguments, $closeBrace] = generated.ast.Selectors.sequence(this.cst);
            return {
                openBrace: $openBrace,
                arguments: new NamedArguments($arguments),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.NamedArgumentGroup);
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
export class NamedArgument {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$name, $colon, $value] = generated.ast.Selectors.sequence(this.cst);
            return {
                name: $name,
                colon: $colon,
                value: new Expression($value),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.NamedArgument);
    }
    get name() {
        return this.fetch().name;
    }
    get colon() {
        return this.fetch().colon;
    }
    get value() {
        return this.fetch().value;
    }
}
export class TypeExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$typeKeyword, $openParen, $typeName, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                typeKeyword: $typeKeyword,
                openParen: $openParen,
                typeName: new TypeName($typeName),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.TypeExpression);
    }
    get typeKeyword() {
        return this.fetch().typeKeyword;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get typeName() {
        return this.fetch().typeName;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
export class NewExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$newKeyword, $typeName] = generated.ast.Selectors.sequence(this.cst);
            return {
                newKeyword: $newKeyword,
                typeName: new TypeName($typeName),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.NewExpression);
    }
    get newKeyword() {
        return this.fetch().newKeyword;
    }
    get typeName() {
        return this.fetch().typeName;
    }
}
export class TupleExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $items, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                openParen: $openParen,
                items: new TupleValues($items),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.TupleExpression);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get items() {
        return this.fetch().items;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
export class TupleValue {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$expression] = generated.ast.Selectors.sequence(this.cst);
            return {
                expression: $expression === undefined ? undefined : new Expression($expression),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.TupleValue);
    }
    get expression() {
        return this.fetch().expression;
    }
}
export class ArrayExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBracket, $items, $closeBracket] = generated.ast.Selectors.sequence(this.cst);
            return {
                openBracket: $openBracket,
                items: new ArrayValues($items),
                closeBracket: $closeBracket,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ArrayExpression);
    }
    get openBracket() {
        return this.fetch().openBracket;
    }
    get items() {
        return this.fetch().items;
    }
    get closeBracket() {
        return this.fetch().closeBracket;
    }
}
export class HexNumberExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$literal, $unit] = generated.ast.Selectors.sequence(this.cst);
            return {
                literal: $literal,
                unit: $unit === undefined ? undefined : new NumberUnit($unit),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.HexNumberExpression);
    }
    get literal() {
        return this.fetch().literal;
    }
    get unit() {
        return this.fetch().unit;
    }
}
export class DecimalNumberExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$literal, $unit] = generated.ast.Selectors.sequence(this.cst);
            return {
                literal: $literal,
                unit: $unit === undefined ? undefined : new NumberUnit($unit),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.DecimalNumberExpression);
    }
    get literal() {
        return this.fetch().literal;
    }
    get unit() {
        return this.fetch().unit;
    }
}
export class YulBlock {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openBrace, $statements, $closeBrace] = generated.ast.Selectors.sequence(this.cst);
            return {
                openBrace: $openBrace,
                statements: new YulStatements($statements),
                closeBrace: $closeBrace,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulBlock);
    }
    get openBrace() {
        return this.fetch().openBrace;
    }
    get statements() {
        return this.fetch().statements;
    }
    get closeBrace() {
        return this.fetch().closeBrace;
    }
}
export class YulFunctionDefinition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$functionKeyword, $name, $parameters, $returns, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                functionKeyword: $functionKeyword,
                name: $name,
                parameters: new YulParametersDeclaration($parameters),
                returns: $returns === undefined ? undefined : new YulReturnsDeclaration($returns),
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulFunctionDefinition);
    }
    get functionKeyword() {
        return this.fetch().functionKeyword;
    }
    get name() {
        return this.fetch().name;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get returns() {
        return this.fetch().returns;
    }
    get body() {
        return this.fetch().body;
    }
}
export class YulParametersDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$openParen, $parameters, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                openParen: $openParen,
                parameters: new YulParameters($parameters),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulParametersDeclaration);
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get parameters() {
        return this.fetch().parameters;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
export class YulReturnsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$minusGreaterThan, $variables] = generated.ast.Selectors.sequence(this.cst);
            return {
                minusGreaterThan: $minusGreaterThan,
                variables: new YulVariableNames($variables),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulReturnsDeclaration);
    }
    get minusGreaterThan() {
        return this.fetch().minusGreaterThan;
    }
    get variables() {
        return this.fetch().variables;
    }
}
export class YulVariableDeclarationStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$letKeyword, $variables, $value] = generated.ast.Selectors.sequence(this.cst);
            return {
                letKeyword: $letKeyword,
                variables: new YulVariableNames($variables),
                value: $value === undefined ? undefined : new YulVariableDeclarationValue($value),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulVariableDeclarationStatement);
    }
    get letKeyword() {
        return this.fetch().letKeyword;
    }
    get variables() {
        return this.fetch().variables;
    }
    get value() {
        return this.fetch().value;
    }
}
export class YulVariableDeclarationValue {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$assignment, $expression] = generated.ast.Selectors.sequence(this.cst);
            return {
                assignment: new YulAssignmentOperator($assignment),
                expression: new YulExpression($expression),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulVariableDeclarationValue);
    }
    get assignment() {
        return this.fetch().assignment;
    }
    get expression() {
        return this.fetch().expression;
    }
}
export class YulVariableAssignmentStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$variables, $assignment, $expression] = generated.ast.Selectors.sequence(this.cst);
            return {
                variables: new YulPaths($variables),
                assignment: new YulAssignmentOperator($assignment),
                expression: new YulExpression($expression),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulVariableAssignmentStatement);
    }
    get variables() {
        return this.fetch().variables;
    }
    get assignment() {
        return this.fetch().assignment;
    }
    get expression() {
        return this.fetch().expression;
    }
}
export class YulColonAndEqual {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$colon, $equal] = generated.ast.Selectors.sequence(this.cst);
            return {
                colon: $colon,
                equal: $equal,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulColonAndEqual);
    }
    get colon() {
        return this.fetch().colon;
    }
    get equal() {
        return this.fetch().equal;
    }
}
export class YulStackAssignmentStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$assignment, $variable] = generated.ast.Selectors.sequence(this.cst);
            return {
                assignment: new YulStackAssignmentOperator($assignment),
                variable: $variable,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulStackAssignmentStatement);
    }
    get assignment() {
        return this.fetch().assignment;
    }
    get variable() {
        return this.fetch().variable;
    }
}
export class YulEqualAndColon {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$equal, $colon] = generated.ast.Selectors.sequence(this.cst);
            return {
                equal: $equal,
                colon: $colon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulEqualAndColon);
    }
    get equal() {
        return this.fetch().equal;
    }
    get colon() {
        return this.fetch().colon;
    }
}
export class YulIfStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$ifKeyword, $condition, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                ifKeyword: $ifKeyword,
                condition: new YulExpression($condition),
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulIfStatement);
    }
    get ifKeyword() {
        return this.fetch().ifKeyword;
    }
    get condition() {
        return this.fetch().condition;
    }
    get body() {
        return this.fetch().body;
    }
}
export class YulForStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$forKeyword, $initialization, $condition, $iterator, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                forKeyword: $forKeyword,
                initialization: new YulBlock($initialization),
                condition: new YulExpression($condition),
                iterator: new YulBlock($iterator),
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulForStatement);
    }
    get forKeyword() {
        return this.fetch().forKeyword;
    }
    get initialization() {
        return this.fetch().initialization;
    }
    get condition() {
        return this.fetch().condition;
    }
    get iterator() {
        return this.fetch().iterator;
    }
    get body() {
        return this.fetch().body;
    }
}
export class YulSwitchStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$switchKeyword, $expression, $cases] = generated.ast.Selectors.sequence(this.cst);
            return {
                switchKeyword: $switchKeyword,
                expression: new YulExpression($expression),
                cases: new YulSwitchCases($cases),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulSwitchStatement);
    }
    get switchKeyword() {
        return this.fetch().switchKeyword;
    }
    get expression() {
        return this.fetch().expression;
    }
    get cases() {
        return this.fetch().cases;
    }
}
export class YulDefaultCase {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$defaultKeyword, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                defaultKeyword: $defaultKeyword,
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulDefaultCase);
    }
    get defaultKeyword() {
        return this.fetch().defaultKeyword;
    }
    get body() {
        return this.fetch().body;
    }
}
export class YulValueCase {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$caseKeyword, $value, $body] = generated.ast.Selectors.sequence(this.cst);
            return {
                caseKeyword: $caseKeyword,
                value: new YulLiteral($value),
                body: new YulBlock($body),
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulValueCase);
    }
    get caseKeyword() {
        return this.fetch().caseKeyword;
    }
    get value() {
        return this.fetch().value;
    }
    get body() {
        return this.fetch().body;
    }
}
export class YulLeaveStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$leaveKeyword] = generated.ast.Selectors.sequence(this.cst);
            return {
                leaveKeyword: $leaveKeyword,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulLeaveStatement);
    }
    get leaveKeyword() {
        return this.fetch().leaveKeyword;
    }
}
export class YulBreakStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$breakKeyword] = generated.ast.Selectors.sequence(this.cst);
            return {
                breakKeyword: $breakKeyword,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulBreakStatement);
    }
    get breakKeyword() {
        return this.fetch().breakKeyword;
    }
}
export class YulContinueStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$continueKeyword] = generated.ast.Selectors.sequence(this.cst);
            return {
                continueKeyword: $continueKeyword,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulContinueStatement);
    }
    get continueKeyword() {
        return this.fetch().continueKeyword;
    }
}
export class YulLabel {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$label, $colon] = generated.ast.Selectors.sequence(this.cst);
            return {
                label: $label,
                colon: $colon,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulLabel);
    }
    get label() {
        return this.fetch().label;
    }
    get colon() {
        return this.fetch().colon;
    }
}
export class YulFunctionCallExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [$operand, $openParen, $arguments, $closeParen] = generated.ast.Selectors.sequence(this.cst);
            return {
                operand: new YulExpression($operand),
                openParen: $openParen,
                arguments: new YulArguments($arguments),
                closeParen: $closeParen,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulFunctionCallExpression);
    }
    get operand() {
        return this.fetch().operand;
    }
    get openParen() {
        return this.fetch().openParen;
    }
    get arguments() {
        return this.fetch().arguments;
    }
    get closeParen() {
        return this.fetch().closeParen;
    }
}
/*
 * Choices:
 */
export class SourceUnitMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.PragmaDirective:
                    return new PragmaDirective(variant);
                case NonterminalKind.ImportDirective:
                    return new ImportDirective(variant);
                case NonterminalKind.ContractDefinition:
                    return new ContractDefinition(variant);
                case NonterminalKind.InterfaceDefinition:
                    return new InterfaceDefinition(variant);
                case NonterminalKind.LibraryDefinition:
                    return new LibraryDefinition(variant);
                case NonterminalKind.StructDefinition:
                    return new StructDefinition(variant);
                case NonterminalKind.EnumDefinition:
                    return new EnumDefinition(variant);
                case NonterminalKind.FunctionDefinition:
                    return new FunctionDefinition(variant);
                case NonterminalKind.ErrorDefinition:
                    return new ErrorDefinition(variant);
                case NonterminalKind.UserDefinedValueTypeDefinition:
                    return new UserDefinedValueTypeDefinition(variant);
                case NonterminalKind.UsingDirective:
                    return new UsingDirective(variant);
                case NonterminalKind.EventDefinition:
                    return new EventDefinition(variant);
                case NonterminalKind.ConstantDefinition:
                    return new ConstantDefinition(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.SourceUnitMember);
    }
    get variant() {
        return this.fetch();
    }
}
export class Pragma {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.AbicoderPragma:
                    return new AbicoderPragma(variant);
                case NonterminalKind.ExperimentalPragma:
                    return new ExperimentalPragma(variant);
                case NonterminalKind.VersionPragma:
                    return new VersionPragma(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.Pragma);
    }
    get variant() {
        return this.fetch();
    }
}
export class ExperimentalFeature {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.StringLiteral:
                    return new StringLiteral(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.ExperimentalFeature);
    }
    get variant() {
        return this.fetch();
    }
}
export class VersionExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.VersionRange:
                    return new VersionRange(variant);
                case NonterminalKind.VersionTerm:
                    return new VersionTerm(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.VersionExpression);
    }
    get variant() {
        return this.fetch();
    }
}
export class VersionOperator {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, NonterminalKind.VersionOperator);
    }
    get variant() {
        return this.fetch();
    }
}
export class VersionLiteral {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.SimpleVersionLiteral:
                    return new SimpleVersionLiteral(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.VersionLiteral);
    }
    get variant() {
        return this.fetch();
    }
}
export class ImportClause {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.PathImport:
                    return new PathImport(variant);
                case NonterminalKind.NamedImport:
                    return new NamedImport(variant);
                case NonterminalKind.ImportDeconstruction:
                    return new ImportDeconstruction(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.ImportClause);
    }
    get variant() {
        return this.fetch();
    }
}
export class UsingClause {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.IdentifierPath:
                    return new IdentifierPath(variant);
                case NonterminalKind.UsingDeconstruction:
                    return new UsingDeconstruction(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.UsingClause);
    }
    get variant() {
        return this.fetch();
    }
}
export class UsingOperator {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, NonterminalKind.UsingOperator);
    }
    get variant() {
        return this.fetch();
    }
}
export class UsingTarget {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.TypeName:
                    return new TypeName(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.UsingTarget);
    }
    get variant() {
        return this.fetch();
    }
}
export class ContractMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.UsingDirective:
                    return new UsingDirective(variant);
                case NonterminalKind.FunctionDefinition:
                    return new FunctionDefinition(variant);
                case NonterminalKind.ConstructorDefinition:
                    return new ConstructorDefinition(variant);
                case NonterminalKind.ReceiveFunctionDefinition:
                    return new ReceiveFunctionDefinition(variant);
                case NonterminalKind.FallbackFunctionDefinition:
                    return new FallbackFunctionDefinition(variant);
                case NonterminalKind.UnnamedFunctionDefinition:
                    return new UnnamedFunctionDefinition(variant);
                case NonterminalKind.ModifierDefinition:
                    return new ModifierDefinition(variant);
                case NonterminalKind.StructDefinition:
                    return new StructDefinition(variant);
                case NonterminalKind.EnumDefinition:
                    return new EnumDefinition(variant);
                case NonterminalKind.EventDefinition:
                    return new EventDefinition(variant);
                case NonterminalKind.ErrorDefinition:
                    return new ErrorDefinition(variant);
                case NonterminalKind.UserDefinedValueTypeDefinition:
                    return new UserDefinedValueTypeDefinition(variant);
                case NonterminalKind.StateVariableDefinition:
                    return new StateVariableDefinition(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.ContractMember);
    }
    get variant() {
        return this.fetch();
    }
}
export class StateVariableAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.OverrideSpecifier:
                    return new OverrideSpecifier(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.StateVariableAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
export class FunctionName {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, NonterminalKind.FunctionName);
    }
    get variant() {
        return this.fetch();
    }
}
export class FunctionAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.ModifierInvocation:
                    return new ModifierInvocation(variant);
                case NonterminalKind.OverrideSpecifier:
                    return new OverrideSpecifier(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.FunctionAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
export class FunctionBody {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.Block:
                    return new Block(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.FunctionBody);
    }
    get variant() {
        return this.fetch();
    }
}
export class ConstructorAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.ModifierInvocation:
                    return new ModifierInvocation(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.ConstructorAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
export class UnnamedFunctionAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.ModifierInvocation:
                    return new ModifierInvocation(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.UnnamedFunctionAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
export class FallbackFunctionAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.ModifierInvocation:
                    return new ModifierInvocation(variant);
                case NonterminalKind.OverrideSpecifier:
                    return new OverrideSpecifier(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.FallbackFunctionAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
export class ReceiveFunctionAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.ModifierInvocation:
                    return new ModifierInvocation(variant);
                case NonterminalKind.OverrideSpecifier:
                    return new OverrideSpecifier(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.ReceiveFunctionAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
export class ModifierAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.OverrideSpecifier:
                    return new OverrideSpecifier(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.ModifierAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
export class TypeName {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.ArrayTypeName:
                    return new ArrayTypeName(variant);
                case NonterminalKind.FunctionType:
                    return new FunctionType(variant);
                case NonterminalKind.MappingType:
                    return new MappingType(variant);
                case NonterminalKind.ElementaryType:
                    return new ElementaryType(variant);
                case NonterminalKind.IdentifierPath:
                    return new IdentifierPath(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.TypeName);
    }
    get variant() {
        return this.fetch();
    }
}
export class FunctionTypeAttribute {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, NonterminalKind.FunctionTypeAttribute);
    }
    get variant() {
        return this.fetch();
    }
}
export class MappingKeyType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.ElementaryType:
                    return new ElementaryType(variant);
                case NonterminalKind.IdentifierPath:
                    return new IdentifierPath(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.MappingKeyType);
    }
    get variant() {
        return this.fetch();
    }
}
export class ElementaryType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.AddressType:
                    return new AddressType(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.ElementaryType);
    }
    get variant() {
        return this.fetch();
    }
}
export class Statement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.IfStatement:
                    return new IfStatement(variant);
                case NonterminalKind.ForStatement:
                    return new ForStatement(variant);
                case NonterminalKind.WhileStatement:
                    return new WhileStatement(variant);
                case NonterminalKind.DoWhileStatement:
                    return new DoWhileStatement(variant);
                case NonterminalKind.ContinueStatement:
                    return new ContinueStatement(variant);
                case NonterminalKind.BreakStatement:
                    return new BreakStatement(variant);
                case NonterminalKind.ReturnStatement:
                    return new ReturnStatement(variant);
                case NonterminalKind.ThrowStatement:
                    return new ThrowStatement(variant);
                case NonterminalKind.EmitStatement:
                    return new EmitStatement(variant);
                case NonterminalKind.TryStatement:
                    return new TryStatement(variant);
                case NonterminalKind.RevertStatement:
                    return new RevertStatement(variant);
                case NonterminalKind.AssemblyStatement:
                    return new AssemblyStatement(variant);
                case NonterminalKind.Block:
                    return new Block(variant);
                case NonterminalKind.UncheckedBlock:
                    return new UncheckedBlock(variant);
                case NonterminalKind.TupleDeconstructionStatement:
                    return new TupleDeconstructionStatement(variant);
                case NonterminalKind.VariableDeclarationStatement:
                    return new VariableDeclarationStatement(variant);
                case NonterminalKind.ExpressionStatement:
                    return new ExpressionStatement(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.Statement);
    }
    get variant() {
        return this.fetch();
    }
}
export class TupleMember {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.TypedTupleMember:
                    return new TypedTupleMember(variant);
                case NonterminalKind.UntypedTupleMember:
                    return new UntypedTupleMember(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.TupleMember);
    }
    get variant() {
        return this.fetch();
    }
}
export class VariableDeclarationType {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.TypeName:
                    return new TypeName(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.VariableDeclarationType);
    }
    get variant() {
        return this.fetch();
    }
}
export class StorageLocation {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, NonterminalKind.StorageLocation);
    }
    get variant() {
        return this.fetch();
    }
}
export class ForStatementInitialization {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.TupleDeconstructionStatement:
                    return new TupleDeconstructionStatement(variant);
                case NonterminalKind.VariableDeclarationStatement:
                    return new VariableDeclarationStatement(variant);
                case NonterminalKind.ExpressionStatement:
                    return new ExpressionStatement(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.ForStatementInitialization);
    }
    get variant() {
        return this.fetch();
    }
}
export class ForStatementCondition {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.ExpressionStatement:
                    return new ExpressionStatement(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.ForStatementCondition);
    }
    get variant() {
        return this.fetch();
    }
}
export class Expression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.AssignmentExpression:
                    return new AssignmentExpression(variant);
                case NonterminalKind.ConditionalExpression:
                    return new ConditionalExpression(variant);
                case NonterminalKind.OrExpression:
                    return new OrExpression(variant);
                case NonterminalKind.AndExpression:
                    return new AndExpression(variant);
                case NonterminalKind.EqualityExpression:
                    return new EqualityExpression(variant);
                case NonterminalKind.ComparisonExpression:
                    return new ComparisonExpression(variant);
                case NonterminalKind.BitwiseOrExpression:
                    return new BitwiseOrExpression(variant);
                case NonterminalKind.BitwiseXorExpression:
                    return new BitwiseXorExpression(variant);
                case NonterminalKind.BitwiseAndExpression:
                    return new BitwiseAndExpression(variant);
                case NonterminalKind.ShiftExpression:
                    return new ShiftExpression(variant);
                case NonterminalKind.AdditiveExpression:
                    return new AdditiveExpression(variant);
                case NonterminalKind.MultiplicativeExpression:
                    return new MultiplicativeExpression(variant);
                case NonterminalKind.ExponentiationExpression:
                    return new ExponentiationExpression(variant);
                case NonterminalKind.PostfixExpression:
                    return new PostfixExpression(variant);
                case NonterminalKind.PrefixExpression:
                    return new PrefixExpression(variant);
                case NonterminalKind.FunctionCallExpression:
                    return new FunctionCallExpression(variant);
                case NonterminalKind.CallOptionsExpression:
                    return new CallOptionsExpression(variant);
                case NonterminalKind.MemberAccessExpression:
                    return new MemberAccessExpression(variant);
                case NonterminalKind.IndexAccessExpression:
                    return new IndexAccessExpression(variant);
                case NonterminalKind.NewExpression:
                    return new NewExpression(variant);
                case NonterminalKind.TupleExpression:
                    return new TupleExpression(variant);
                case NonterminalKind.TypeExpression:
                    return new TypeExpression(variant);
                case NonterminalKind.ArrayExpression:
                    return new ArrayExpression(variant);
                case NonterminalKind.HexNumberExpression:
                    return new HexNumberExpression(variant);
                case NonterminalKind.DecimalNumberExpression:
                    return new DecimalNumberExpression(variant);
                case NonterminalKind.StringExpression:
                    return new StringExpression(variant);
                case NonterminalKind.ElementaryType:
                    return new ElementaryType(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.Expression);
    }
    get variant() {
        return this.fetch();
    }
}
export class ArgumentsDeclaration {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.PositionalArgumentsDeclaration:
                    return new PositionalArgumentsDeclaration(variant);
                case NonterminalKind.NamedArgumentsDeclaration:
                    return new NamedArgumentsDeclaration(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.ArgumentsDeclaration);
    }
    get variant() {
        return this.fetch();
    }
}
export class NumberUnit {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, NonterminalKind.NumberUnit);
    }
    get variant() {
        return this.fetch();
    }
}
export class StringExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.StringLiteral:
                    return new StringLiteral(variant);
                case NonterminalKind.StringLiterals:
                    return new StringLiterals(variant);
                case NonterminalKind.HexStringLiteral:
                    return new HexStringLiteral(variant);
                case NonterminalKind.HexStringLiterals:
                    return new HexStringLiterals(variant);
                case NonterminalKind.UnicodeStringLiterals:
                    return new UnicodeStringLiterals(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.StringExpression);
    }
    get variant() {
        return this.fetch();
    }
}
export class StringLiteral {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, NonterminalKind.StringLiteral);
    }
    get variant() {
        return this.fetch();
    }
}
export class HexStringLiteral {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, NonterminalKind.HexStringLiteral);
    }
    get variant() {
        return this.fetch();
    }
}
export class UnicodeStringLiteral {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, NonterminalKind.UnicodeStringLiteral);
    }
    get variant() {
        return this.fetch();
    }
}
export class YulStatement {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.YulBlock:
                    return new YulBlock(variant);
                case NonterminalKind.YulFunctionDefinition:
                    return new YulFunctionDefinition(variant);
                case NonterminalKind.YulStackAssignmentStatement:
                    return new YulStackAssignmentStatement(variant);
                case NonterminalKind.YulIfStatement:
                    return new YulIfStatement(variant);
                case NonterminalKind.YulForStatement:
                    return new YulForStatement(variant);
                case NonterminalKind.YulSwitchStatement:
                    return new YulSwitchStatement(variant);
                case NonterminalKind.YulLeaveStatement:
                    return new YulLeaveStatement(variant);
                case NonterminalKind.YulBreakStatement:
                    return new YulBreakStatement(variant);
                case NonterminalKind.YulContinueStatement:
                    return new YulContinueStatement(variant);
                case NonterminalKind.YulLabel:
                    return new YulLabel(variant);
                case NonterminalKind.YulVariableDeclarationStatement:
                    return new YulVariableDeclarationStatement(variant);
                case NonterminalKind.YulVariableAssignmentStatement:
                    return new YulVariableAssignmentStatement(variant);
                case NonterminalKind.YulExpression:
                    return new YulExpression(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.YulStatement);
    }
    get variant() {
        return this.fetch();
    }
}
export class YulAssignmentOperator {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.YulColonAndEqual:
                    return new YulColonAndEqual(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.YulAssignmentOperator);
    }
    get variant() {
        return this.fetch();
    }
}
export class YulStackAssignmentOperator {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.YulEqualAndColon:
                    return new YulEqualAndColon(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.YulStackAssignmentOperator);
    }
    get variant() {
        return this.fetch();
    }
}
export class YulSwitchCase {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.YulDefaultCase:
                    return new YulDefaultCase(variant);
                case NonterminalKind.YulValueCase:
                    return new YulValueCase(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.YulSwitchCase);
    }
    get variant() {
        return this.fetch();
    }
}
export class YulExpression {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            switch (variant.kind) {
                case NonterminalKind.YulFunctionCallExpression:
                    return new YulFunctionCallExpression(variant);
                case NonterminalKind.YulLiteral:
                    return new YulLiteral(variant);
                case NonterminalKind.YulBuiltInFunction:
                    return new YulBuiltInFunction(variant);
                case NonterminalKind.YulPath:
                    return new YulPath(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.YulExpression);
    }
    get variant() {
        return this.fetch();
    }
}
export class YulPathComponent {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, NonterminalKind.YulPathComponent);
    }
    get variant() {
        return this.fetch();
    }
}
export class YulBuiltInFunction {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            return variant;
        });
        assertKind(this.cst.kind, NonterminalKind.YulBuiltInFunction);
    }
    get variant() {
        return this.fetch();
    }
}
export class YulLiteral {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const variant = generated.ast.Selectors.choice(this.cst);
            if (variant.isTerminalNode()) {
                return variant;
            }
            switch (variant.kind) {
                case NonterminalKind.HexStringLiteral:
                    return new HexStringLiteral(variant);
                case NonterminalKind.StringLiteral:
                    return new StringLiteral(variant);
                default:
                    throw new Error(`Unexpected variant: '${variant.kind}'.`);
            }
        });
        assertKind(this.cst.kind, NonterminalKind.YulLiteral);
    }
    get variant() {
        return this.fetch();
    }
}
/*
 * Repeated:
 */
export class SourceUnitMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new SourceUnitMember(item));
        });
        assertKind(this.cst.kind, NonterminalKind.SourceUnitMembers);
    }
    get items() {
        return this.fetch();
    }
}
export class VersionExpressionSet {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new VersionExpression(item));
        });
        assertKind(this.cst.kind, NonterminalKind.VersionExpressionSet);
    }
    get items() {
        return this.fetch();
    }
}
export class ContractMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new ContractMember(item));
        });
        assertKind(this.cst.kind, NonterminalKind.ContractMembers);
    }
    get items() {
        return this.fetch();
    }
}
export class InterfaceMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new ContractMember(item));
        });
        assertKind(this.cst.kind, NonterminalKind.InterfaceMembers);
    }
    get items() {
        return this.fetch();
    }
}
export class LibraryMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new ContractMember(item));
        });
        assertKind(this.cst.kind, NonterminalKind.LibraryMembers);
    }
    get items() {
        return this.fetch();
    }
}
export class StructMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new StructMember(item));
        });
        assertKind(this.cst.kind, NonterminalKind.StructMembers);
    }
    get items() {
        return this.fetch();
    }
}
export class StateVariableAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new StateVariableAttribute(item));
        });
        assertKind(this.cst.kind, NonterminalKind.StateVariableAttributes);
    }
    get items() {
        return this.fetch();
    }
}
export class FunctionAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new FunctionAttribute(item));
        });
        assertKind(this.cst.kind, NonterminalKind.FunctionAttributes);
    }
    get items() {
        return this.fetch();
    }
}
export class ConstructorAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new ConstructorAttribute(item));
        });
        assertKind(this.cst.kind, NonterminalKind.ConstructorAttributes);
    }
    get items() {
        return this.fetch();
    }
}
export class UnnamedFunctionAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new UnnamedFunctionAttribute(item));
        });
        assertKind(this.cst.kind, NonterminalKind.UnnamedFunctionAttributes);
    }
    get items() {
        return this.fetch();
    }
}
export class FallbackFunctionAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new FallbackFunctionAttribute(item));
        });
        assertKind(this.cst.kind, NonterminalKind.FallbackFunctionAttributes);
    }
    get items() {
        return this.fetch();
    }
}
export class ReceiveFunctionAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new ReceiveFunctionAttribute(item));
        });
        assertKind(this.cst.kind, NonterminalKind.ReceiveFunctionAttributes);
    }
    get items() {
        return this.fetch();
    }
}
export class ModifierAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new ModifierAttribute(item));
        });
        assertKind(this.cst.kind, NonterminalKind.ModifierAttributes);
    }
    get items() {
        return this.fetch();
    }
}
export class FunctionTypeAttributes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new FunctionTypeAttribute(item));
        });
        assertKind(this.cst.kind, NonterminalKind.FunctionTypeAttributes);
    }
    get items() {
        return this.fetch();
    }
}
export class Statements {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new Statement(item));
        });
        assertKind(this.cst.kind, NonterminalKind.Statements);
    }
    get items() {
        return this.fetch();
    }
}
export class CatchClauses {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new CatchClause(item));
        });
        assertKind(this.cst.kind, NonterminalKind.CatchClauses);
    }
    get items() {
        return this.fetch();
    }
}
export class StringLiterals {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new StringLiteral(item));
        });
        assertKind(this.cst.kind, NonterminalKind.StringLiterals);
    }
    get items() {
        return this.fetch();
    }
}
export class HexStringLiterals {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new HexStringLiteral(item));
        });
        assertKind(this.cst.kind, NonterminalKind.HexStringLiterals);
    }
    get items() {
        return this.fetch();
    }
}
export class UnicodeStringLiterals {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new UnicodeStringLiteral(item));
        });
        assertKind(this.cst.kind, NonterminalKind.UnicodeStringLiterals);
    }
    get items() {
        return this.fetch();
    }
}
export class YulStatements {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new YulStatement(item));
        });
        assertKind(this.cst.kind, NonterminalKind.YulStatements);
    }
    get items() {
        return this.fetch();
    }
}
export class YulSwitchCases {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const items = generated.ast.Selectors.repeated(this.cst);
            return items.map((item) => new YulSwitchCase(item));
        });
        assertKind(this.cst.kind, NonterminalKind.YulSwitchCases);
    }
    get items() {
        return this.fetch();
    }
}
/*
 * Separated:
 */
export class VersionExpressionSets {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new VersionExpressionSet(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.VersionExpressionSets);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class SimpleVersionLiteral {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return { items: items, separators: separators };
        });
        assertKind(this.cst.kind, NonterminalKind.SimpleVersionLiteral);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class ImportDeconstructionSymbols {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new ImportDeconstructionSymbol(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ImportDeconstructionSymbols);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class UsingDeconstructionSymbols {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new UsingDeconstructionSymbol(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.UsingDeconstructionSymbols);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class InheritanceTypes {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new InheritanceType(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.InheritanceTypes);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class EnumMembers {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return { items: items, separators: separators };
        });
        assertKind(this.cst.kind, NonterminalKind.EnumMembers);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class Parameters {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new Parameter(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.Parameters);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class OverridePaths {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new IdentifierPath(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.OverridePaths);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class EventParameters {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new EventParameter(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.EventParameters);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class ErrorParameters {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new ErrorParameter(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ErrorParameters);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class AssemblyFlags {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new StringLiteral(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.AssemblyFlags);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class TupleDeconstructionElements {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new TupleDeconstructionElement(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.TupleDeconstructionElements);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class PositionalArguments {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new Expression(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.PositionalArguments);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class NamedArguments {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new NamedArgument(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.NamedArguments);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class CallOptions {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new NamedArgument(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.CallOptions);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class TupleValues {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new TupleValue(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.TupleValues);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class ArrayValues {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new Expression(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.ArrayValues);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class IdentifierPath {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return { items: items, separators: separators };
        });
        assertKind(this.cst.kind, NonterminalKind.IdentifierPath);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class YulParameters {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return { items: items, separators: separators };
        });
        assertKind(this.cst.kind, NonterminalKind.YulParameters);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class YulVariableNames {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return { items: items, separators: separators };
        });
        assertKind(this.cst.kind, NonterminalKind.YulVariableNames);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class YulArguments {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new YulExpression(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulArguments);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class YulPaths {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new YulPath(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulPaths);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
export class YulPath {
    constructor(cst) {
        this.cst = cst;
        this.fetch = once(() => {
            const [items, separators] = generated.ast.Selectors.separated(this.cst);
            return {
                items: items.map((item) => new YulPathComponent(item)),
                separators: separators,
            };
        });
        assertKind(this.cst.kind, NonterminalKind.YulPath);
    }
    get items() {
        return this.fetch().items;
    }
    get separators() {
        return this.fetch().separators;
    }
}
/*
 * Helpers:
 */
function once(factory) {
    let value;
    return () => {
        if (value === undefined) {
            value = factory();
        }
        return value;
    };
}
function assertKind(actual, expected) {
    if (actual !== expected) {
        throw new Error(`AST node '${expected}' can only be initialized with a CST node of the same kind. Received '${actual}' instead.`);
    }
}
